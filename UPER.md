<h1>The Problem Solving Framework : 'UPER'</h1>

* U = "Understand"
* P = "Plan"
* E = "Execute"
* R = "Reflect" / "Refactor"

<h2>1. Understanding the Problem</h2>

<p>The task at hand is to create a terminal based game written in Java that implements the Object-Oriented programming
 and
 design patterns we have learned thus far. One key point I had to clarify before fully understanding where to begin
  was my project structure. After cloning the repository, I learned that there was no <ins>src</ins> folder in my
   project and when trying to add a new package, I was not given the option. After verifying my work must be sorted
    into packages that are logically structured, I had to figure out how to create a package. I created a folder
     named src, but still was unable to create packages or classes from within it. Finally I figured out that I had
      to set the newly created src folder as the <ins>Sources Root</ins> in order to create new packages and classes
       inside of it. After figuring out how to allow for the proper structuring of my project, I moved on to
        identifying the details of the problem.</p>
<p>My game must be functional and playable by the user, contain instructions that are built-in and available as a
 separate file, and use the four pillars of OOP: encapsulation, inheritance, abstraction, and polymorphism. Each
  "game object" must be modelled using a Java class and the game must implement at least 1 interface, 1 abstract
   class, 1 lambda expression, and 1 stream. Lastly, my game must have at least one package and be structured
    logically, and have some type of error handling for bad user input.</p>
    
<h2>
    2. Planning the Solution
</h2>
<p>The first step I took when planning my solution was to identify which game I would like to work on and why. My
 initial thoughts were minesweeper, flappy bird, and snake. The reason for those choices were because they were each
  games that I found myself playing all the time growing up. After reading through the instructions for this project
   in great detail and reading through the article provided in our instructions, I decided to go down the path of
    creating a text-based game that allows the user to make choices that take them down certain paths dependent upon
     those choice. The reason I decided to go down this path rather than that of my original game ideas is because I
      feel as though the simplistic nature of a text-based game will really allow me to take full control over the
       project and incorporate OOP and OOD patterns more cohesively. I was also able to find extensive amounts of
        information online regarding how to develop a text-based Java game.
       </p>
<p>After determining what type of game I was going to create, I began coming up with a UML diagram to map how I was
 going to code it out.</p>

<br>


<h2>
    3. Executing the Plan
</h2>


<br>


<h2>
    4. Reflection / Refactor
</h2>

